# ADR 003: 서버 상태 관리를 위한 TanStack Query (React Query) 사용

## 상태

채택됨

## 맥락

-   현대 웹 애플리케이션은 API로부터 비동기적으로 데이터를 가져오고, 캐싱하며, 동기화하는 복잡한 로직을 필요로 합니다.
-   `useEffect`와 `useState`를 조합하여 직접 데이터 페칭 로직을 작성하는 것은 로딩 및 에러 상태 관리, 재시도(retry), 캐싱, 데이터 동기화 등에서 많은 보일러플레이트 코드를 유발하고 오류를 발생시키기 쉽습니다.
-   서버 상태(Server State)는 클라이언트 상태(Client State)와 본질적으로 다르며, '오래된 데이터(stale)'가 될 수 있다는 특징을 가집니다.

## 결정

-   서버 상태 관리 라이브러리로 **TanStack Query (구 React Query)**를 채택합니다.

## 근거

1.  **선언적인 데이터 페칭**:
    -   `useQuery` 훅을 사용하여 "어디서 데이터를 가져올지"만 선언하면, TanStack Query가 나머지(로딩, 에러, 성공 상태)를 자동으로 관리해줍니다. 복잡한 `useEffect` 로직을 작성할 필요가 없습니다.

2.  **강력한 캐싱 전략**:
    -   한 번 가져온 데이터는 메모리에 캐싱되어, 동일한 요청이 다시 발생할 때 캐시된 데이터를 즉시 반환하여 사용자 경험을 향상시킵니다.
    -   `stale-while-revalidate` 전략을 기본으로 사용하여, 캐시된 데이터를 먼저 보여준 뒤 백그라운드에서 최신 데이터를 가져와 UI를 업데이트합니다.

3.  **자동 동기화 및 재시도**:
    -   창(window)에 다시 포커스가 가거나, 네트워크가 재연결될 때, 또는 설정된 시간 간격에 따라 데이터를 자동으로 다시 가져와(refetch) 항상 최신 상태를 유지하도록 돕습니다.
    -   데이터 페칭 실패 시, 자동으로 몇 차례 재시도를 수행하여 일시적인 네트워크 문제에 대응합니다.

4.  **서버 상태와 클라이언트 상태의 분리**:
    -   TanStack Query는 서버에서 비롯된 상태를, Zustand는 순수 클라이언트 상태를 각각 전담하여 관리하도록 역할을 명확히 분리합니다. 이는 애플리케이션의 상태 관리 구조를 더 명확하고 예측 가능하게 만듭니다.

## 결과

-   개발자는 `services` 디렉터리에 정의된 API 호출 함수를 `useQuery`의 `queryFn`으로 전달하여 간단하게 서버 데이터를 가져오고 관리할 수 있습니다.
-   데이터 페칭과 관련된 복잡한 로직(로딩, 에러, 캐싱 등)을 직접 구현할 필요가 없어 비즈니스 로직에 더 집중할 수 있습니다.
-   Devtools를 통해 쿼리의 상태와 캐시된 데이터를 시각적으로 확인할 수 있어 디버깅이 용이합니다.
